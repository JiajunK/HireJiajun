<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../style.css"/>
  <title>Different Methods of Getting "There"</title>
</head>
<body>
<header class="back"><a href="../writing.html">Back</a></header>
<div class="writing">
  <h3>Different Methods of Getting “There”</h3>
  <br>
  <p>Peeking through the dark hallway, with only a small flashlight that shines two feet ahead of you, you walk for what seems like an eternity. The silence is deafening. You feel as if you could not breathe in the dark fog and suddenly, you hear footsteps that do not belong to yourself. All of a sudden you miss the silence that you dreaded a minute ago. You were as quiet as possible and you could swear there was nothing behind you a minute ago. How did that monster find you? The non-playable characters in video games are controlled by artificial intelligence. What exactly constitutes “artificial intelligence”? This term is overused and often misused by the media. According to the Merriam-Webster dictionary, artificial intelligence is defined as “a branch of computer science dealing with the simulation of intelligent behavior in computers” and also “the capability of a machine to imitate intelligent human behavior”. Upon further examination, these are extremely vague definitions. For example, if a calculator can calculate the square root of 999, it technically does imitate intelligent human behavior. However, most people would not consider a calculator as “artificial intelligence”.To take the definition of artificial intelligence more liberally, this paper will also consider the hardcoded, scripted movements of a non-playable character as an example of artificial intelligence. Going back to the initial example of a monster finding the player in the dark, a hard coded monster would automatically pop out when an if statement is met, and will follow a precise, pre-scripted, path. Another way the monster could find the player is by a pathfinding algorithm. The most popular ones are A-star, commonly written as A*, and Dijikstra. Finally, a decision tree could be used to determine how the monster moves and react. How are all these techniques different and what can each of these provide? To begin, a hardcoded “artificial intelligence” would be the easiest to implement, but most restrictive.
  </p>
  <br>
  <p>  Hard coding artificial intelligence is a vague term. In fact, there is no official term for this type. Some people call it scripted because the code is not alterable. According to the Wikipedia page for hard coding, the term “hard-coded” was initially used as an analogy to hand wiring circuits and was meant to convey the inflexibility that results from its usage within software design and implementation. When a player reaches a certain point in the map, the monster is automatically triggered and walks towards that point to meet the player.  It does not matter how the player reached this point (crouch, walk, or run); the monster will just catch up to the player. The code itself just tells the monster to go from point A, to point B. It could be coded so it loops between point A and point B or just stops at point B. This could be done by simple if statements and the coordinates could be preset to make it happen. The benefits of hard coding a non-playable character are to force events to happen at certain checkpoints of the game, force the player into choosing another path or make the player think of strategies to beat the pattern. Hard coding movements is the most basic artificial intelligence that can be applied to many different situations. Unlike other methods, this method does not have specific implementation methods or algorithms to follow. It could be as easy as a couple if statements, or as difficult as thousands of lines of code. The run time and disk time will vary depending on the implementation. For a beginner programmer, this may be the easiest option as they can utilize whatever tool they are comfortable with. The great thing about hard coding a character is the programmer gets total control over it. Debugging is much easier as the programmer can break it apart and see exactly where the problem lies. If the character does not require complicated movement, hard coding a script will be quick and easy. However, a scripted artificial intelligence has its limitations. If the player ever does something unexpected or untested and blocks the artificial intelligence from performing its script, the entire game could easily break. Depending on the implementation, clipping, awkward movement, or other graphical bugs could be common. In addition, since it is the programmer’s own implementations, it could be difficult for other team members to edit or utilize the code. In fact, the definition of hardcode by the Cambridge dictionary is defined as “...a software program that cannot be easily changed by a user”. The code may not be easily reusable for other non-playable characters, and each different non-playable character will need its own script. Overall, hardcoding a script as artificial intelligence could work in cases where the movement is simple or  not expected to be reused. If the programmer is looking for a smarter, more complex, and reusable movement, the programmer should consider pathfinding algorithms.
  </p>
  <br>
  <p>
    Pathfinding algorithms are algorithms that find the shortest route between two points. The programmer may implement different costs or weights into the equation. Two of the most common algorithm used in games are A* and Dijkstra. A* is a graph traversal method, which is perfect for games with maps. The algorithm has a main loop that finds the least cost. It will calculate the cost of traversing a certain path, and ultimately calculate the total cost to extend the path to the goal. A* will terminate when the lowest potential-cost path leads to the goal. Usually it is used to calculate the path before executing the movement, meaning it will not waste time walking into a dead end. There is still flexibility with the implementation, such as using a linked list or a priority queue, depending on the user’s preference. Dijkstra’s is similar in a sense that it will search for the shortest path from the starting point to all end points. Compared to A*, it seems more of a brute force approach as it exams every unvisited neighbor node and expands outwards. Both of these methods are predefined and have many implementations available online. There are many pseudocode implementations online that a programmer could use as a guideline, as well as templates in many programming languages. Because these are predefined algorithms, it should not be labor intensive to implement. The good thing about pathfinding algorithms is how smart the non-playable character will look. If the programmer is looking for the artificial intelligence to roam freely and be difficult to hide from, this would be a great method to implement. In addition, the player will have the feeling of playing against a real human, if implemented correctly. Because the computer is “thinking” and making its decisions as it goes, there will be no patterns the player can outsmart. On the other hand, because the movement is automated, the programmer will have little control over it. Unexpected bugs could happen as is it difficult to test every single scenario and anticipate every answer the computer will give. In addition, using pre-existing code may be hard to convert between program to program. The time complexity could be much greater, making it not suitable for non-playable characters that have little to do with the main game. Another question that may arise is what if the player is not looking for the shortest path, and more factors in their movement decisions? The decision tree method can solve that problem.
  </p>
  <br>
  <p>
    A decision tree is a tool that considers different situations and produces many different outcomes. It is not only used in movement, but also used in research, strategies, and machine learning. The programmer implements a flowchart of tree nodes, each internal node being a question to ask the program and each leaf being a decision to be made. Say for example the programmer wants the non-playable character to not only find the player, but also destroy environments as it goes. The decision tree could be implemented so the monster checks if the environment is breakable, then breaks, then see if they are closer to the player. There is much more flexibility and variety of moments that could be made with decision tree implementations. The decision tree could be as simple or as complex as the programmer desires. Simple decision trees could be easy if statements, while others could be designed with machine learning. There are some templates for decision trees available on the web, and many different examples as well. Since decision trees are an idea that have been around for many years, there are a lot of resources that can teach the programmer how to implement one. Unlike the previously stated methods, a decision tree can be simple, complex, unique, controllable, and duplicatable. The same decision tree could be reused across multiple different non-playable characters, and it is easy to duplicate and edit the small details across different characters. Unfortunately, not every method is perfect. A decision tree movement may not be as fluid as pathfinding algorithms, and may not be the most efficient either. In addition, the player could find patterns to outsmart the artificial intelligence once they decide the conditions it checks for. Because programmers are responsible for the entire implementation, just like hard coding, it could be difficult for colleagues or clients to understand what the code exactly does. Overall, there are different needs for different methods.
  </p>
  <br>
  <p>
  Which method is the best? This question cannot be answered definitively as each program has different needs. In terms of running time, a pathfinding algorithm will often cost much more than implementing a decision tree. Then, implementing a decision tree is often more costly than hard coding a script. Similarly, for memory, a pathfinding algorithm must store a representation of the search space, causing much greater memory consumption than the other two techniques. A decision tree could cost a lot of memory depending on its implementation, however, hard coding a script will typically not take much memory. Going back to the original example, how did the monster find the player? If the monster was scripted, then it was automatically triggered and knew exactly which coordinates to head to at a certain time. This requires only linear complexity and linear memory. If the monster was using a pathfinding algorithm, it has been searching the player for a while, and will avoid all obstacles and reach the player in the shortest distance possible. The pathfinding cod was likely running heavily in the background, taking up much memory. Finally, if a decision tree was used, perhaps the monster was checking different directions of the map, checking for light in a certain direction, or checking for footsteps from a certain direction. The memory usage might not have been as heavy as a pathfinding monster, but more heavy than a scripted monster. Overall, the complexity desired of these artificial intelligence will determine which method is the best method. Programming can be as easy as telling a monster to go to point B, or as complex as asking the monster to think about how and why it should go to point B.
  </p>
  <br>
  <h3>Citations</h3>
  <br>
  <p>Amit, Patel. “Introduction to A*.” Standford University, Red Blob Games, 16 Feb. 2020, theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html. <br>
    Bhiksha, Raj. “Decision Trees.” Decision Trees, Carnegie Mellon University, www.cs.cmu.edu/~bhiksha/courses/10-601/decisiontrees/.<br>
    “Hard Coding.” Wikipedia, en.wikipedia.org/wiki/Hard_coding.<br>
    “Hardcode.” Cambridge Dictionary, Cambridge University Press, dictionary.cambridge.org/dictionary/english/hardcode. <br>
    Kingsford, Carl, and Steven L Salzberg. “What Are Decision Trees?” US National Library of Medicine National Institutes of Health, NCBI, 24 June 2009, www.ncbi.nlm.nih.gov/pmc/articles/PMC2701298/. <br>
    Yan, Meliss. “Dijkstra's Algorithm.” MIT Mathematics, Massachusetts Institute of Technology, math.mit.edu/~rothvoss/18.304.3PM/Presentations/1-Melissa.pdf. <br>
  </p>
</div>
</body>
</html>